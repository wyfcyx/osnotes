## 内存中的类型

### 对齐

任何数据结构都要至少对齐到1字节（否则的话，为了完整访问一个字节我们需要两次对齐的字节访问）

**对齐访问是为了性能和同步性问题**，比如可以在64位CPU上自然对齐（naturally aligned）到8字节

出于同样的原因，编译器也会将数据结构放置在一个对齐的位置上

原生类型会对齐到它们自身的大小，复合数据结构将会按照其中最大的原生类型的大小进行对齐

### 内存布局

内存布局：一般情况下Rust数据结构的布局比较玄学，好在我们可以用`repr(C)`让其与C一致从而变得更加明确，在FFI的时候也会比较有用。

另一个有用的representation是`repr(transparent)`，它可以保证一个仅含有单个域的结构体的内存布局与这个域单拎出来的内存布局相同，否则Rust编译器不保证这一点。这个特性可以用来为既有类型提供额外功能但不改变其内存布局。

`repr(C)`的内存对齐规则是：按照字段被声明的顺序对字段进行排布；每个字段都要符合它们类型的对齐要求，因此字段之间可能需要填充一些padding；在所有字段排布完成后，可能还需要在末尾加上padding来确保整个结构体的大小是对齐要求最苛刻字段对齐要求的整数倍，这样如果整个结构体被放到一个数组中的话仍然能满足对齐要求；整个结构体的对齐要求与对齐要求最苛刻字段的对齐要求相同。

相比而言，Rust默认的结构体表示`repr(Rust)`可能会对字段进行重排以及其他优化，从而缩减结构体的大小，其代价是用户无法预测其具体的内存布局。

`repr(packed)`可以让编译器移除字段之间用于对齐的padding。好处是可以节约内存；缺点则是要承受非对齐访问的性能开销，以及在某些不支持非对齐访问的CPU上程序可能会崩溃。

使用`#[repr(align(n))]`可以让结构体对齐到n字节，n应该是2的幂且不低于该结构体的最低对齐要求。通过这种方法我们可以让一个数据结构对齐到cacheline的大小并避免false sharing。

### 复合类型

