[link](https://zackoverflow.dev/writing/unsafe-rust-vs-zig)

作者指出了Rust在编写大量unsafe代码时候（比如，在实现一个类似JVM的字节码runtime）不舒服的地方。由于这里涉及到大量的内存分配，因此常规的safe Rust API已经不足以解决问题了，所以这个时候需要用到大量的Rust黑魔法API，也需要涉及到大量unsafe内容。但是编写unsafe代码具有相当的难度，因为Rust编译器会基于一些假设（特别是和引用相关的）进行优化，这些假设对Rust开发者提出了很高的要求，比如要求开发者们完全遵从Rust的所有权规则，不然的话Rust会直接优化出UB。而且一个可能更加严重的问题是，Rust目前没有严格定义在unsafe代码中应该做什么以及不应该做什么。目前Rust只是在[这个页面](https://doc.rust-lang.org/reference/behavior-considered-undefined.html)列出了一些已知的UB行为，但是还会有其他未知的UB行为（但是，难道其他语言就能够定义出所有的UB吗？我觉得事实上也只能给出一个spec并声明spec之外的都是UB。然而回过头来想想，在引入了引用语义之后，确实会出现很多更加微妙的UB情形）。于是，Rust官方推荐unsafe代码开发者事先阅读Rust nomicon。为了减轻UB的问题，一个比较有用的工具是Miri，它可以基于Rust的中间表示MIR检测出部分UB。然而，即使能够检测到，将其修复也可能很不容易。

作者将上面的问题归功于Rust中的引用。他的看法可能是，如果没有在充分理解Rust的所有权规则的情况下编程，使用引用很可能会导致更多的UB，这样的话，还不如回去写C语言呢。为了绕过引用，作者尝试使用裸指针，但是发现写起来非常不方便，因为很多API都是需要传入引用而不是裸指针的。于是，某些时候作者尝试将裸指针转换为引用（显然是unsafe行为），但是又遇到了非常困难的问题：也就是别名问题。在同一个上下文中，如果通过裸指针转换，使得（实质上，形式上不一定长成这个样子）同时存在同个变量的共享/可变（或者多个可变）引用，这就有可能触发UB（但由于用到了unsafe，编译器可能检查不出来）。然后又需要去通过Miri定位，然后修复云云。

这导致作者直接弃疗去用Zig了。对于我们则需要反思的是：Rust过于信任程序员能够遵从所有权模型和引用语义，从而有可能进行大量相对C/Zig更为激进的优化，但这其实是有隐患的。如果开发者没有达到Rust所期望的水平该怎么办？