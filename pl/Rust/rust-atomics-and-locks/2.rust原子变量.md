多线程并发读**写**同一个变量会导致数据竞争，也就是UB。这本书的第七章居然还深入到原子读写的硬件实现？这么厉害的嘛？

原子操作是搭建各种复杂的同步原语如锁和条件变量的基础。

Rust的原子类型有些要依赖操作系统？但是硬件层面至少原生提供一种（通用寄存器位宽）的原子变量。

Rust的原子类型提供内部可变性，而且支持Send和Sync。

`Ordering::Relaxed`保证单内存位置的一致性（因为原子读写无论如何是要拉到总线上仲裁的，底层逻辑是缓存一致性协议如MESI协议），但是不能保证多变量的操作之间的相对顺序。也就是说，多个核（或者说多线程）观测到的内存的变化情况是不一样的。比如，一个线程先写入变量A再写入变量B，另一个线程则很有可能看到变量B先于变量A被写入。不过在这一章中，我们仅考虑`Ordering::Relaxed`。
