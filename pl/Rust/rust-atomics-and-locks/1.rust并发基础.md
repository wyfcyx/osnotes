`println!`自带锁`std::io::Stdout::lock()`，因此不同线程上的`println!`之间并不会出现混淆。

一个线程的生命周期可以和整个程序的生命周期相同。因此`spawn`的参数带有一个`'static`生命周期trait bound，如果我们按引用捕获一个主线程中的局部变量，整个闭包就不符合`'static`了。（然而我们使用`move`的话就可以吗？

如果线程没有正常退出的话，`join`会返回错误。

`spawn`是`std::thread::Builder::new().spawn().unwrap()`的简写。使用`thread::Builder`可以对创建的线程进行更多设置，比如设置线程栈大小或者线程名字等。注意创建新线程是不一定成功的，比如操作系统可能内存耗尽等。

带作用域的线程scoped threads：如果确信一个线程不会活得比某个作用域更长，那么这样的线程就可以安全的借用局部变量。`std::thread::scope`可以用来创建线程，该线程不会比我们传给`scope`的闭包活得更长。传给`scope`的闭包带有一个参数`s`，表示scope，可以使用`s.spawn`来创建线程，在闭包的结尾所有这样创建出来的线程会自动join。

> safe的Rust API不能假定对象总是会在它们的生存期结束后被drop（比如说循环引用等情况）。
>
> 所以，安全的`scope`并不依赖于Drop trait。

如果线程间需要共享数据的话，该共享数据需要活得比所有线程都要长。最简单的方式是直接开`static`全局变量。使用`Box::leak`可以泄露堆内存，得到一个`&'static T`，这块内存在程序生命周期内都不会被drop掉。

`'static`生命周期仅意味着它会和整个程序活得一样长，对于它生命周期何时开始则不作约束

但是使用`Box::leak`会放弃掉`Box<T>`对堆上数据的所有权，另一种做法是**共享所有权**（这种说法比起多所有权更好吗？）。基础的引用计数是`Rc`，但是它并不是`Send`的。于是应该换成`Arc`。

> 在*Naming Clones*有一些shadowing和利用scopes的小技巧，这些我们基本上都已经用过了，但是可能没有解释过。

共享所有权和共享引用有着相同的限制条件：那就是不能修改数据。

在Rust中有两种借用：不可变借用（共享，是Copy的）和可变借用（独占）。如果能够做到以上两点的话，便可避免**数据竞争**。数据竞争是指当一个线程正在修改共享资源的时候，另一个线程也正在访问它。数据竞争对于Rust来说是UB（对于其他语言应该也是），编译器会简单假设其不存在。

> 每种编程语言都会有一系列规则，当不遵循规则编程的时候将会导致UB，这是我们不惜任何代价也要避免的。在Rust中，其中一条这样的规则就是任何对象都不能同时存在两个可变引用。unsafe意味着编译器没有能力帮我们检查是否在块内遵循了规则。编译器会假定我们遵循了规则。
>
> 将`&T`转换为`&mut T`在Rust中也是UB。

如果仅使用共享引用的话线程间无法进行通信。考虑内部可变性，在共享的同时仍然可变！下面是提供内部可变性的几种类型：

* `Cell<T>`，只能用于单线程，用法有些类似于`Option<T>`
* `RefCell<T>`，只能用于单线程，维护共享和独占引用的计数
* `RwLock<T>`是`RefCell<T>`的并发版本，`Mutex<T>`则是某种简化版本
* 各种原子类型
* `UnsafeCell<T>`是内部可变性的基本原语，它自身提供`get`方法可以得到内部数据的裸指针

---

线程安全性：Send和Sync

Send: 一个该类型的值的所有权可以被转移到其他线程上。

Sync: `T`是`Sync`等价于`&T`是`Send`。

所有原生类型都同时是`Sync`和`Send`的。

裸指针`*const T`和`*mut T`不是`Sync`也不是`Send`的。

---

拿着`MutexGuard`的线程如果panic，该锁会被污染（腐化？），带来一系列问题。

使用`if let`有的时候会扩大`MutexGuard`的作用域，因为可能会认为borrow了某些东西，而`if`由于结果仅仅是一个boolean，就不会有这种情况。

`Mutex<T>`和`RwLock<T>`都要求`T`是`Send`的，因为它们可以用来将一个`T`发送到另一个线程。此外`RwLock<T>`还要求`T`是`Sync`的，因为通过`RwLock<T>`的API我们很容易使得多个线程上有同一个`&T`，如果`T`不是`Sync`的就出现UB了。

> 所以逻辑可能是这样：比如`RwLock<T>`已经有一组固定的接口。如果它是`Sync`的，意味着多线程都可以安全的拿到`&RwLock<T>`，进而可以同时拿到`&T`，这意味着`T`至少必须是`Sync`的。所以反过来说，如果`T`不是`Sync`的话，`RwLock<T>`也不是。但其实`RwLock<T>`是`Sync`还需要`T`是`Send`的。其实这个属于在lock这里比较通用的逻辑了，无论拿到共享还是独占引用拷贝一份应该都没什么问题。

在实现`RwLock<T>`需要注意读者优先还是写者优先的问题。

C++里面的`std::mutex`并不包裹它保护的数据。

---

使用`thread::park`可以阻塞当前线程，一个thread对象调用`unpark`可以唤醒这个线程。

`unpark`的奇怪机制：当线程正常运行的时候，`unpark`并不是丢失而是会被记录下来。下次`park`该线程的时候，这次`unpark`记录会被清除，而线程则不会被阻塞。但是`unpark`的**层数上限只有一层**！

后面应该是在讨论`park`和`unpark`的某些局限性吧...看不下去了。

---

看到条件变量之前...