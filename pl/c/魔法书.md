[链接](https://github.com/weaiken/ebook/blob/master/01_programming/C++/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E9%AD%94%E6%B3%95%E4%B9%A6%E5%9F%BA%E4%BA%8EC11%E6%A0%87%E5%87%86-6.pdf)

# 第四章：C语言中的基本元素

`#include <stdio.h>`是一种`#include`预处理器。

提到预处理token的概念。

identifier可用字符：大小写字母、0-9和下划线，不能以数字开头。

`#include <stdbool.h>`将`_Bool`定义为`bool`；`#include <complex.h>`将`_Complex`定义为`complex`

字符串前缀：`u8`代表UTF-8，`u`代表UTF-16，而`U`代表UTF-32

C11包括了结构体、联合体和数组的复合字面量，复合字面量似乎不再是常量而是变量。

# 第五章：基本数据类型

`sizeof`操作符和`_Alignof`操作符返回值的类型都是`size_t`，定义在`<stddef.h>`中。使用`size_t`作为一个指针或地址转换一个整数的方式。在GCC和Clang下，`size_t`被定义为`unsigned long`，无论在32还是64位环境下都能存放一个地址。打印`size_t`的时候可以使用`%zu`。

`ptrdiff_t`作为两个指针相减的结果类型，位宽与`size_t`相同，但是有符号。

标准整数类型定义在`<stdint.h>`中，从`int8_t`到`uint64_t`；能存放对象指针的整数类型，包括`intptr_t`和`uintptr_t`，分别是有符号和无符号的。

看到了5.3，明天有空接着看。

# 第六章：用户自定义类型

位域中的匿名字段默认填充0，可以用来对齐。

`_Alignof`操作符返回一个类型的对齐要求，在`<stdalign.h>`中可以找到相同功能的`alignof`。

`_Alignas`显式指出一个对象的对齐要求，在`<stdalign.h>`中可以找到相同功能的`alignas`。

`<stddef.h>`中有`offsetof`宏，用法如`offsetof(struct S, a)`，返回字段`a`在结构体`struct S`中的偏移量。

# 第七章：C语言的数组与指针

C99之后已经允许变长数组了。在GNU语法拓展中，允许长度为0的数组，其占用0字节存储空间。

数组初始化一些新的写法：

```c
// 指定下标初始化器，但是感觉不推荐这种写法...
// 这里编译器会自动推断数组长度
int16_t s[] = { -1, 2, [3] = 10, [6] = 5, [4] = 1, 20};
```

不能将一个数组对象赋值给另一个数组对象（初始化的时候也不行），而是只能单个赋值或者使用`memcpy`。

变长数组不能在文件作用域中声明，不能用static修饰。变长数组与指向变长数组的指针统称**可变修改类型**。当对可变修改类型进行sizeof的时候，将会在运行期计算，且sizeof里面的表达式才会产生运行期的副作用。变长数组不能直接初始化，只能逐个赋值或者通过`memcpy`。

`*`被称为间接操作符，因为可以通过指针对象间接访问它指向对象的值。

取地址运算符的操作数一般不能是一个右值（rvalue），即一个表达式的值。而左值（lvalue）代表一个具体的对象，则可以取地址。

指针与数组的相互转换和指针算术已经比较熟悉了。

注意当数组对象作为sizeof、__Alignof以及`&`操作符的操作数的时候，`[T]`不能被自动转换为`T*`。

指向数组对象的指针（这个跟函数指针也挺像的）：

```c
int a[3];
int (*p)[3] = &a;
printf("%d\n", (*p)[1]); // (*p)相当于p[0]
printf("%d\n", p[0][1]);
```

void类型的表达式被称为void表达式，即不返回任何值也没有任何意义。万用指针类型`void*`，与其他指针类型可以*相互*隐式类型转换。

C语言中的空指针为宏`NULL`，事实上是`(void*)0`。

# 第八章：C语言控制流语句

感觉逗号表达式有点太tricky了，可读性-=1。

才发现for循环里面居然可以声明变量的，舒服。

# 第九章：C语言的函数

如果形参列表为空，应该使用`void`。

可以使用`T*`来表示变长数组类型，但是如果根据安全规范需要同时带上数组长度。

在函数的返回值类型之前存在一个存储类说明符，可以是`static`或者`extern`，默认为`extern`。所以内部函数应该手动使用`static`。

传参数的时候要注意可能的拷贝开销（move语义大法好！）

看到9.2之前。

# 第十章：C语言预处理器

