[链接](https://github.com/weaiken/ebook/blob/master/01_programming/C++/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E9%AD%94%E6%B3%95%E4%B9%A6%E5%9F%BA%E4%BA%8EC11%E6%A0%87%E5%87%86-6.pdf)

# 第四章：C语言中的基本元素

`#include <stdio.h>`是一种`#include`预处理器。

提到预处理token的概念。

identifier可用字符：大小写字母、0-9和下划线，不能以数字开头。

`#include <stdbool.h>`将`_Bool`定义为`bool`；`#include <complex.h>`将`_Complex`定义为`complex`

字符串前缀：`u8`代表UTF-8，`u`代表UTF-16，而`U`代表UTF-32

C11包括了结构体、联合体和数组的复合字面量，复合字面量似乎不再是常量而是变量。

# 第五章：基本数据类型

`sizeof`操作符和`_Alignof`操作符返回值的类型都是`size_t`，定义在`<stddef.h>`中。使用`size_t`作为一个指针或地址转换一个整数的方式。在GCC和Clang下，`size_t`被定义为`unsigned long`，无论在32还是64位环境下都能存放一个地址。打印`size_t`的时候可以使用`%zu`。

`ptrdiff_t`作为两个指针相减的结果类型，位宽与`size_t`相同，但是有符号。

标准整数类型定义在`<stdint.h>`中，从`int8_t`到`uint64_t`；能存放对象指针的整数类型，包括`intptr_t`和`uintptr_t`，分别是有符号和无符号的。

看到了5.3，明天有空接着看。

# 第六章：用户自定义类型

位域中的匿名字段默认填充0，可以用来对齐。

`_Alignof`操作符返回一个类型的对齐要求，在`<stdalign.h>`中可以找到相同功能的`alignof`。

`_Alignas`显式指出一个对象的对齐要求，在`<stdalign.h>`中可以找到相同功能的`alignas`。

`<stddef.h>`中有`offsetof`宏，用法如`offsetof(struct S, a)`，返回字段`a`在结构体`struct S`中的偏移量。

# 第七章：C语言的数组与指针

C99之后已经允许变长数组了。在GNU语法拓展中，允许长度为0的数组，其占用0字节存储空间。

数组初始化一些新的写法：

```c
// 指定下标初始化器，但是感觉不推荐这种写法...
// 这里编译器会自动推断数组长度
int16_t s[] = { -1, 2, [3] = 10, [6] = 5, [4] = 1, 20};
```

不能将一个数组对象赋值给另一个数组对象（初始化的时候也不行），而是只能单个赋值或者使用`memcpy`。

变长数组不能在文件作用域中声明，不能用static修饰。变长数组与指向变长数组的指针统称**可变修改类型**。当对可变修改类型进行sizeof的时候，将会在运行期计算，且sizeof里面的表达式才会产生运行期的副作用。变长数组不能直接初始化，只能逐个赋值或者通过`memcpy`。

`*`被称为间接操作符，因为可以通过指针对象间接访问它指向对象的值。

取地址运算符的操作数一般不能是一个右值（rvalue），即一个表达式的值。而左值（lvalue）代表一个具体的对象，则可以取地址。

指针与数组的相互转换和指针算术已经比较熟悉了。

注意当数组对象作为sizeof、__Alignof以及`&`操作符的操作数的时候，`[T]`不能被自动转换为`T*`。

指向数组对象的指针（这个跟函数指针也挺像的）：

```c
int a[3];
int (*p)[3] = &a;
printf("%d\n", (*p)[1]); // (*p)相当于p[0]
printf("%d\n", p[0][1]);
```

void类型的表达式被称为void表达式，即不返回任何值也没有任何意义。万用指针类型`void*`，与其他指针类型可以*相互*隐式类型转换。

C语言中的空指针为宏`NULL`，事实上是`(void*)0`。

# 第八章：C语言控制流语句

感觉逗号表达式有点太tricky了，可读性-=1。

才发现for循环里面居然可以声明变量的，舒服。

# 第九章：C语言的函数

如果形参列表为空，应该使用`void`。

可以使用`T*`来表示变长数组类型，但是如果根据安全规范需要同时带上数组长度。

在函数的返回值类型之前存在一个存储类说明符，可以是`static`或者`extern`，默认为`extern`。所以内部函数应该手动使用`static`。

传参数的时候要注意可能的拷贝开销（move语义大法好！）

对函数标志（即函数名，调用哪个函数）的计算和对函数实参的计算是可以并行的，编译器并不会安排它们的顺序。这两步完成之后才会进行函数调用。在使用函数指针数组的情况下，会需要对函数标志进行计算。

看到9.2.3之前。

调用者负责将实参push到栈上；如果返回值类型为一个结构体的话，则结构体首先开在被调用者的stackframe上，然后在返回的时候还需要拷贝到调用者的stackframe上。也就是说，调用者和被调用者各在各自的栈帧上有一份函数参数。

当函数形参是一个数组类型时，它会被自动转换为相应的指针类型。

带有不定参数类型和个数的函数调用：不定形参列表使用`...`表示，要求`...`之前必须至少有一个形参且`...`之后不能有形参。由于参数类型不确定，编译器将采用默认的实参晋升机制，使得精度低于`int`的类型晋升到`int`，同时`float`晋升到`double`。`<stdarg.h>`给出了不定参数列表的类型`va_list`，还有操作它的几个宏。

使用方法：要处理可变参数的时候，首先声明一个`va_list`类型的变量（假如说是`ap`）。再假设可变参数列表`...`之前的最后一个形参名字为`a`，最开始需要`va_start(ap, a);`对`ap`进行初始化。然后可以通过`va_arg(ap, <argument_type>)`来依次获取可变参数列表中的每个参数，注意参数类型需要设置为`int`或`double`，即使传入参数的精度较低。在取出所有参数之后，使用`va_end(ap)`对`ap`进行无效化。还有另外一个宏`va_copy`可以对`va_list`进行拷贝，参数为`dest_va_list`和`src_va_list`，前者复制后者的初始化和迭代器状态。

函数说明符`inline`将函数标记为内联函数，暗示编译器该函数要尽可能快，可以在调用者上下文中直接操作，当然也只是建议，最终如何做由编译器决定。如果打算和`extern`和`static`联合使用的话则有一些注意事项，目前还没太看懂。

函数的返回：函数必须以`return`结尾（即使返回值类型为`void`也有隐藏的`return`），返回值类型可以为各种类型或指向它们的指针，但不能为数组。如果函数在不触及`return`的情况下结束应该是一个UB。C11标准在`<stdnoreturn.h>`中将`_Noreturn`定义为`noreturn`，这也是一个函数说明符，表明函数不会返回。函数说明符应当放置在函数返回值类型之前。

函数指针类型：`<return_type> (* [cv限定符] identifier) (<argument_list>)`。这里的cv限定符即为`const`或者`volatile`。如果有一个函数指针对象为`void (*pFunc) (void)`，则`&pFunc`的类型为`void (**) (void)`。

# 第十章：C语言预处理器

# 第十一章：C语言程序的编译上下文

同一个标识符在程序的不同位置（作用域）可能会表示不同的实体，C语言的标识符允许被覆盖。C语言中的作用域有：函数作用域、文件作用域、语句块作用域和函数原型作用域。

为了避免名字空间污染，在结构体中嵌套声明其他结构体或联合体的时候尽量匿名，不然的话这些嵌套结构也将拥有文件作用域，于是它们在同文件的任何位置均可访问。

跳转标签名是仅有的具有函数作用域的标识符，即使标签在函数内的一个语句块中，也不受到该语句块作用域的影响。

函数原型作用域：没什么用

语句块作用域：标识符出现在语句块或者函数形参列表中，则该标识符具有语句块作用域。

标识符的重定义和作用域的叠交：就是里层作用域的标识符会覆盖掉外层作用域相同的标识符，好像需要类型相同。目前也没必要深入研究。

名字空间：就是说有些情况下，相同标识符出于不同使用目的会引起冲突，有些则不会。没必要深究，尽量避免相同标识符就行了。

对象与函数的链接：一个对象或函数标识符可以在不同或相同作用域内进行多次声明，这些重复的声明可以通过称为链接的过程来引用同一对象获函数。C语言中有三种链接类型：外部链接、内部链接以及无链接。

看到11.2之前。
