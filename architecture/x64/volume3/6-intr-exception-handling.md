# 中断/异常处理

保护模式下的中断/异常处理机制，然而大部分也适用于virtual 8086、实模式和64位模式。

## 中断/异常总览

中断通常来自外部硬件，然而软件也可以通过INT n生成中断。

异常与指令执行有关。

> 中断/异常上下文是由软件还是硬件保存的？

## 中断/异常向量

vector=2，表示不可屏蔽的外部中断

vector=32-255，表示用户定义的中断，包括外部中断或者INT n

## 中断来源

### 外部中断

外部中断从CPU引脚或通过local APIC接收。主要的中断引脚是LINT[1:0]，连接到local APIC。当local APIC使能的时候，...当local APIC被禁用的时候，LINT分别被设置为INTR和NMI引脚。INTR通知CPU来了一个外部中断，CPU需要从总线读取外部中断控制器（如8259A）提供的中断向量编号。NMI则通知CPU来了一个不可屏蔽中断。

每个CPU的local APIC一般连接到系统级的IOAPIC上。从而IOAPIC收到的中断信号可以通过总线被转发到local APIC上。IOAPIC决定中断向量编号并将它发给local APIC。多核情况下，一个CPU可以通过系统总线或者APIC串行总线发送中断到另一个CPU。

注意CPU上还有其他几个引脚可以触发中断。然而，这些中断的处理并不会走中断/异常handler的流程。

### 可屏蔽硬件中断

通过INTR引脚或者local APIC收到的外部中断被称为可屏蔽硬件中断。

EFLAGS.IF允许所有可屏蔽硬件中断一并被屏蔽。

### 软件生成的中断

INT n指令隐式调用中断向量编号为n的handler。0-255均可作为参数传给INT。但当n=2（NMI）的时候会有所不同。INT n生成的中断不能通过设置EFLAGS.IF屏蔽。

## 不可屏蔽中断

NMI的生成方式有两种：要么是外设通过CPU的NMI引脚发过来，要么是CPU收到了系统总线或者APIC串行总线发过来的投递模式为NMI的消息。当CPU收到NMI的时候，立即调用对应的handler来处理它。同时在此期间CPU还会屏蔽掉任何其他中断（包括新的NMI）。当NMI从上述两个源头收到的时候，它是不能被EFLAGS.IF屏蔽的。

如果从INTR引脚收到中断向量2，那么NMI的handler会被调用。但是此时它并不会被视作NMI，上面提到的机制也均不会生效。

处理多个NMI：略

## 打开/关闭中断

CPU禁止某些中断的生成，这取决于CPU的状态和EFLAGS.IF/RF标志位。

我们这里只关心EFLAGS.IF可以屏蔽掉所有可屏蔽硬件中断就好了。

