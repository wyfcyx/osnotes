IA-32架构提供实模式、保护模式、模拟8086模式和系统管理模式。Intel64架构在IA-32的基础上，新增了IA-32e模式，又分为64位模式和兼容模式。

本章后面的描述大部分基于IA-32架构的保护模式。Intel64架构的IA-32e模式与之有着些许不同，也会被提到。

所有的IA-32或Intel64架构的处理器上电后都会进入实模式。通过软件可以切换到保护模式。而Intel64架构CPU可以从保护模式切换到IA-32e模式。

## 系统级架构回顾

### 全局/局部描述符表

保护模式下，所有内存访问通过全局描述符表GDT或者（可选地）局部描述符表LDT。它们的表项被称为段描述符，包括段基址、访问权限、类型和使用方法等信息。每个段描述符关联到一个段选择子。段选择子包含对应段描述符在GDT/LDT中的偏移、一个局部/全局标志、以及访问权限信息。

要访问段内的一个字节，必须提供段选择子和段内偏移。通过段选择子可以访问段描述符。从段描述符可以得到线性地址空间内的段基址，再加上段内偏移就得到了字节的线性地址。该机制可以用来访问合法的代码、数据、堆栈段，前提是CPU当前特权级CPL被允许访问这个段。CPL被定义为当前的代码段的protection level。

GDT和LDT的基址（**线性地址**）分别保存在寄存器GDTR和LDTR中。

在IA-32e模式下，GDTR和LDTR被拓展到64位，GDT和LDT也被拓展从而支持64位基址。

### 系统段、段描述符和门

除了构成程序执行环境的代码段、数据段和堆栈段，架构定义了两个系统段：TSS和LDT。GDT不被认为是一个段因为它并不会以段选择子和段描述符的方式访问。而TSS和LDT有为他们定义的段描述符。

架构还定义了一组特殊的**叫做门的描述符**（包括调用门、中断门、陷入门和任务门）。它们用来访问通常与应用不在一个特权级的系统procedures和handlers。比如，CALL一个调用门可以访问一个更高特权级的代码段。要这样做的话，调用者需要提供这个调用门的段选择子。CPU随后针对这个调用门进行权限检查，比较CPL、调用门的特权级还有调用门指向的目标代码段的特权级。

如果检查通过，CPU可以得到目标代码段的段选择子并从调用门中获取目标代码段的段内偏移。如果这次调用会切换特权级，CPU还需要进行换栈（涉及TSS）。

IA-32e模式下，LDT描述符、64位TSS、调用门、中断门和陷入门为16字节。调用门可以用于64位模式和兼容模式之间的转换。任务门不再支持。当特权级变更时，SS不再从TSS加载而是被设置为NULL。

### TSS和任务门

TSS定义了一个任务的执行环境的状态，包括通用寄存器、段寄存器、EFLAGS、EIP、还有3个不同特权级（Ring0-2）下的栈的SS/ESP。TSS还包括这个任务的LDT的段选择子以及分页数据结构的基址。

保护模式下，所有程序的执行均在当前任务的上下文内进行。当前任务的TSS的段选择子保存在TR寄存器中。要切换到一个任务，最简单的方法是进行调用或者跳转到新任务。这里，新任务的TSS的段选择子作为CALL/JMP指令的参数。在进行切换操作的任务中，CPU进行：

1. 保存当前任务的上下文到当前任务的的TSS；
2. 加载新任务的TR，该TR是一个段选择子；
3. 通过GDT里面的一个段描述符访问新任务的TSS；
4. 从新任务的TSS中加载新任务的上下文，包括通用寄存器、段寄存器、LDTR（因此局部描述符表应该是per task的）、CR3（即页表基址）、EFLAGS和EIP；
5. 开始执行新任务。

一个任务也可以通过任务门访问。任务门类似于调用门，区别在于它指向任务的TSS而非一个代码段。

IA-32e模式下，不支持硬件任务切换，但TSS仍然存在。TSS的基址由对应段描述符给出。64位TSS保存如下信息：每个特权级下的ESP；中断栈表的指针；IO权限位图的偏移量。TR被拓展到64位。

### 中断/异常处理

外部中断、软件中断和异常通过IDT处理。该IDT保存一组门描述符，指向中断/异常handler。和GDT一样，IDT并不是一个段（因此没有对应的段描述符），寄存器IDTR保存IDT的基址（线性地址）。

IDT中的门描述符可以是中断、陷入、或任务描述符。为了访问一个中断/异常handler，CPU需要从内部硬件、外部中断控制器、或者INT n等指令获取中断向量。中断向量是IDT索引，指向IDT中的一个门描述符。如果描述符是中断/陷入，流程与调用门接近；否则需要进行任务切换。

在IA-32e模式下（对于64位模式和兼容模式），中断门描述符拓展到16字节来支持64位基址。IDTR也被拓展。不支持任务门。

### 内存管理

当不打开分页的时候，线性地址被视作物理地址；否则，所有的数据、代码、堆栈和系统段（包括GDT/IDT）可以被放在物理内存最近访问的页面上。物理页帧的位置在页表中，页表也放置在物理内存中。页表基址保存在CR3中。

在IA-32e模式下，物理页帧被一组系统数据结构管理。在64位模式和兼容模式下，会用到四级或五级数据结构。

### 系统寄存器

* EFLAGS中的系统标志位和IOPL字段控制任务和模式切换、中断处理、指令跟踪和访问权限；
* 控制寄存器CR0/CR2/CR3/CR4；
* 调试寄存器；
* GDTR/LDTR/IDTR；
* TR；
* MSR（Model-Specific Registers）：主要提供给Ring0软件，包括调试拓展、性能计数器等。

在IA-32e模式下，GDTR/LDTR/IDTR/TR被拓展；EFLAGS变为64位的RFLAGS；CR0-CR4拓展到64位；CR8变为可用，它提供读写权限到TPR（Task Priority Register）使得OS可以控制外部中断的优先级类别。其余暂时省略。

## EFLAGS系统级标志位

可能比较有用的是：

* IF(Interrupt Enable, 9)，控制CPU如何处理可屏蔽硬件中断。IF不影响异常或者不可屏蔽中断（NMI）的生成。CPL、IOPL和CR4.VME决定IF能否被CLI/STI/POPF/POPFD/IRET等指令修改。
* IOPL(I/O Privilege Level)，表示当前程序或任务的I/O特权级。CPL必须不低于IOPL来访问I/O地址空间。仅当CPL=0的时候POPF和IRET等指令才能修改IOPL。IOPL还可以控制IF的修改等。

IA-32e模式下，RFLAGS的高32位保留。不允许将VM位置1因为不支持virtual 8086模式。同时，CPU不会设置NT位，但允许软件设置NT位。SYSCALL/SYSRET指令有一种可编程方法来指定EFLAGS/RFLAGS中的哪些位被清空。这些指令负责保存/恢复EFLAGS和RFLAGS。

## 系统级指令总结

Mark一下，2.8.6有关于TSC的信息。