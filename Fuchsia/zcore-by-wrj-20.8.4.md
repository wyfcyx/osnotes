# zCore 整体设计

## 项目背景与开发历史

### 动机

* rCore 处于课程期间快速发展，clear & dirty
* 某些设计存在问题，代码混乱
* rjgg 本人对于微内核结构感兴趣
* rCore 存在问题
  1. 大量不 Rust 代码
  2. 模块化不够
  3. 基于 Linux 存在 fork 等糟粕

### 开发历史

* 调研（2019.10 开始）
  * 微观：内核对象如何设计
  * 宏观：系统启动、运作流程
* 用 Rust 实现基础内核对象（2019.12 开始）
  * 进程管理、内存管理用于启动第一个进程
  * 使用单元测试：`cargo test` 方便但不能用于裸机环境，`cargo xtest` 比较复杂；类比软件工程中的 `moop` 思想，抽象出硬件抽象层，将测试跑起来
  * 由此，进一步思索用户态 OS 的可行性（用户态 userboot）
* 探索 async Rust 用法，确立整体架构（2020.1 开始）
* 具体开发阶段，将 Linux 用户态程序移植到裸机（2020.2-2020.4）
* 后续进一步增强功能

### 展望

* 用户态测试
* 模块化良好

## zCore 整体结构

* 随着编译选项不同表现为不同的形态，在裸机上运行的，在 Linux 用户态运行的...
* Rust 和 C 同时实现 Zircon，性能处于同一量级

## HAL 硬件抽象层设计实现

* 动机：实现用户态测试
* 做法：用户态模拟内核机制：`std::thread` 模拟内核线程；大文件存整块物理内存模拟分页、`mmap`
* 黑科技：只在用户态，搞定特权级转换
* 接口设计：接口库 `kernel-hal` 定义弱链接，具体实现 `kernel-hal-<platform>` 定义强实现函数，链接时会将接口函数覆盖

## async Rust

* **用同步风格编写异步代码**

* 本质：无栈协程，非抢占式调度

* 每个执行流都有自己独立的栈，意味着可以被**抢占**；而所有协程共用一个栈，自然不支持被抢占？

* 节省内存：事实上，任意时刻所有执行流所需在栈上保存的信息之和的上限比较小，而单个执行流所需最大的栈空间上限较大；因此协程相比线程更节省内存

* 2020.03.21 async 在 no_std 中正式可用

* 工作机制：Reactor 类比 OS 中的中断函数唤醒被阻塞的任务，一张非常清晰的图片说明 async 的调用流程

* Future 呈树状结构

  * 底层：需要为所有的叶子（不依赖任何其他 Future）手动实现 `poll` 函数

  * 中层：基于 async-await 对于子 Future 进行组合

    高级用法：使用 `select!` 实现 超时处理 和 异步取消功能，用 `join!` 实现同步

  * 上层：用 Executor 运行 Future，目前已有运行时：

    * libos: `tokio/async-std`，支持多线程，可以模拟多核
    * 裸机：`rcore-os/executor`，simple 单核

* 系统调用的不同风格

  * 传统：内核即将返回到用户态之前，内核栈上的内容会被清空，举例：spawn
  * zCore：内核看到的是函数调用，用户态期间内核栈上的东西不会丢失

## 一点人生经验

