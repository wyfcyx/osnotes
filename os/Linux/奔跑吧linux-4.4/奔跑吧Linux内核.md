# 《奔跑吧 Linux 内核》notes

## Log

### 2020/8/15

* 这本书基于 ARM 架构分析了 Linux 4.0 版本的关键模块的代码。正好这两项都是我不太了解的，正好趁着烧 sdcard 的间隙学习一下。

## Ch1 处理器体系结构

### 1.2 端序

* 给出了内存布局图看起来更容易理解（高低字节分布与地址增长顺序的关系）
* 利用 C 联合体来检查 CPU 当前的端序设置（ARMv8 CPU 的端序可以配置）

### 1.3 指令在 CPU 中的执行原理

* 作者分析了 x86 处理器和 ARM Cortex-A9 处理器的模块设计来解释现代计算机体系结构中的很多概念，目前先不深入，了解即可
* 比较有趣的一点是寄存器重命名，比如额外引入临时寄存器来消除数据冲突
* 另外还发现之前不了解的地方是：即使多发射、乱序执行，但是在提交的时候却是顺序的。也就是说即使两条指令完全不冲突，排在后面的指令也不能将数据先写回寄存器

### 1.4 内存屏障

* 内存乱序访问就是说实际访问内存的顺序与程序编写规定的顺序存在差异。

* 内存乱序访问主要分成两个阶段：

  1. 编译时编译器进行优化；
  2. 运行时多 CPU 交互引起的乱序访问。

* 每个核都有自身的内存访问序列，而在多核情况下它们会被乱序**归并**成一个访问序列

  但为了保证内存访问的某种**一致性**，需要对于归并的方式有所限制，使得整体的访问序列满足某种规则

  这种限制与规则称为**内存一致性**模型，一个设计的好的模型既需要满足正确性（内存访问与程序的语义一致），也需要尽可能提高多核并行度

* 对于单核处理器，内存访问的正确性很容易保证。当我们读内存时，它一定是最近被写入的结果。

* 对于多核，在某一个核上读内存的结果是否受到其他核对于同样内存地址的写入的影响则是一个问题。

  

