“任务”是调度的最小单元，线程和协程可分别看成长时/短时任务；基于共享内存实现“共享调度器”；尽量在用户态完成任务切换避免陷入内核态，也就是说尽量将位于同一“地址空间”的任务分组完成，因为切换地址空间需要陷入到内核态；飓风内核是协作式的异步内核。

异步设备驱动/文件系统->异步系统调用->异步标准库

用户和内核态均需要实现执行器Executor，它们均访问同一个任务队列，即“共享调度器”；执行器从共享调度器中取出任务，如果可以在当前地址空间中运行则直接`Future::poll`，否则（如果用户态需要进行系统调用）切换地址空间运行被取出的任务。

异步virtio块设备驱动：大概是最终提交请求的那一步是一个叶子Future，poll这个Future会将最外层Future加入到等待队列，当然要在这个过程中完成event注册之类的。读写请求的时候，内核填充写端ring buffer并阻塞当前任务；收到外部中断时，则在中断服务例程中读取读端ring buffer，并唤醒相应任务。这里用到的被修改为可以在``no_std``环境下运行的`event-listener`库。K210 SD卡驱动不知道怎么做异步，因为它原生不太支持中断，难道真的是用DMA中断?不过它声称是异步的我们就仔细看看。基于异步块设备驱动自然可以实现异步FS（这里实现的是FAT32）。

> 异步SD卡驱动核心在于[`async_response`方法](https://github.com/HUST-OS/tornado-os/blob/main/async-sd/src/lib.rs#L341)。

共享调度器：用户和内核的执行器使用相同的代码（因而，是相同的逻辑）从队列中取出任务来执行。虽然用户不能干涉内核的执行，但是依然可能偷取敏感信息（考虑侧信道攻击），这其实破坏了confidentiality。接口的稳定和兼容性，有助于维护生态？共享调度器被编译为一个独立的可执行文件（包括代码和数据段），被（也是独立？）加载到物理内存中，运行时被同时映射到内核和应用的地址空间，这样内核和应用就能使用相同的代码访问相同的数据。然而文中也提到这样是不安全的，不过没有进行比较具体的分析。

协程间基于管道的异步通信以及异步锁：这个到时候再说...

应用和内核从共享调度器尝试取任务可能会得到不同的结果：执行特定任务/切换地址空间/任务池为空。大概可以理解为：每个地址空间上有一个Executor管理本地址空间内的任务，Executor作为这个地址空间内的main loop不断调用共享调度器并进行处理（显然内核和应用测Executor的逻辑不同，应用的执行器在应用标准库中），但是到了要切换地址空间的时候就需要保存当前Executor上下文再进行切换。但是不太能理解的是执行当前地址空间内的任务返回Pending的时候为啥要保存任务上下文，这个应该不需要显式保存而是已经将任务进度记录在Future里面了。这个后面再看代码确定一下。