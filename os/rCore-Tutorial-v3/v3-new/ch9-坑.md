* 坑1：不能直接`jr trap_from_kernel`，暂时使用`sscratch`进行中转

* 在`read_block`的时候，还没有进入`condvar.wait`之前就打开中断使得中断不能唤醒任何任务，从而该任务永久卡死

  这个应该如何解决呢

  这需要将`condvar`封装到`upintrfreecell`中形成一个类似于`sleeplock`的结构，这样保证我们总能将进程加入到等待队列后再开启中断
  
  何时才是开启中断的好时机？大概可以看到有这样几个时间点：
  
  1. 当前进程被加入等待队列
  2. 调用`block_current_and_run_next`函数，取出当前任务并将其任务设置为BLOCKING
  3. 调用`schedule`触发调度
  
  我觉得设置为BLOCKING无关紧要，但是感觉应该是设置为BLOCKING之后就可以开中断了。因此很有必要将`block_current_and_run_next`中的`schedule`单独拆分出来。
  
* 另外忽然想起一个好点子是：要不要自己写spinlock/sleeplock?

  实际上并不是这个点子。而是在`upsafecell`中新增一个接收闭包的函数，这样就能在函数返回之后自动释放锁，这在很多时候会很大程度上简化代码，也会“更加Rust”。
  
* 目前还不支持在内核时钟中断的时候进行调度。

  看了一下，xv6的处理也仅是在当前有进程且进程处于RUNNING状态的时候才会触发调度。而进程状态是有SLEEPING这一项的。

  因此目前还是暂不考虑。

* 坑2：使用`jr`不会保存ra，需要使用`jalr`

* 坑3：`INTR_MASKING_INFO`不能附加额外的处理逻辑，所以底层要基于`UnsafeCell`而不是`RefCell`

* note：暂时将输出换回sbi，能得到更多信息。

* 坑4：read block特别特别慢，而且进入shell之后很大可能卡死

* 坑5：在syscall之后关闭中断，发现暂时不再出现卡死现象，且程序运行速度似乎有所提升？

  如何解释？原先是哪里存在死锁呢？

  让我们看下xv6后续是否也有关闭中断的操作。

  果然找到了！在`set_user_trap_entry`之前需要关闭中断。否则，此时触发中断的话又会进入（来自）用户态trap的处理入口，而我们本应该期望它进入来自内核态Trap的入口。事实上也就是说：回到用户态的这段代码是不可被打断的，此前我们并未意识到这一点。