来自20230401的OS大赛讲座

从应用出发的逻辑：实现和概念总是在变，从需求和问题**导出**“一种实现”和概念

希望培养的几种核心能力：

发散式思考：讲清楚问题之后，同学们往往能给出一些初步的解决方案，可以和OS中沉淀下来的成熟解决方案进行对比

三步走：程序员视角（需求）->硬件支持（可选，某些功能没有下沉到硬件，但是软硬件的边界很难说明）->os如何实现



为什么需要线程，需求和时代背景

我猜应该是多核处理器的诞生->应用单进程无法充分利用CPU资源->多进程架构->通信开销大->多线程架构



点->面->网



实验设置：

warm0：bomb，参考csapp，用于熟悉aarch64汇编

warm1: shell，了解常见的syscall，应该是写一些简单的linux程序

lab列表：系统启动->内存管理->进程与上下文切换->调度、通信、同步->用户态文件系统&命令行

**后面lab需要merge前面的工作**



如何降低实验复杂度：基础框架、任务文档、评分脚本（每个lab的每个stage都可以单独测试）

特点：微内核架构，基于capability；优点：更容易定制、裁剪，内核代码量小



途径：好大学在线chmooc，ipads.se.sjtu.edu.cn/mospi，gitee上面找chcore（有两个版本，后一个版本涵盖IO/futex等功能），educoder.net（现代操作系统体验版，联网就能做实验）

这个平台可能是我们比较缺失的部分

使用expects工具进行make grade