## 某些问题

### 第二章

* 特权级的相关描述可能有些问题。（这个已经在评论区发布了，看情况更新文档）

### 第六章

* 块缓存是否被及时刷新
* 文件系统里面使用`Mutex`而不是`UPSafeCell`，是否有相关说明

### 第七章

* `sigaction`的语义不明

* `user_lib`里面`sigaction`的接口根据一贯的风格应该是`&mut`

* `sys_kill`的代码是个啥...?

* `sys_kill`的接口有歧义，体现在测试用例`sig_simple2`中，比如传进去的到底应该是10还是`1<<10`?

  更新：从[IBM](https://www.ibm.com/docs/en/zos/2.4.0?topic=functions-kill-send-signal-process)的文档看来应该是10而不是`1<<10`。其中明确指出了是最多一个信号。

* 从[这里](https://linux.die.net/man/2/sigreturn)来看，`sigreturn`在Linux中的实现似乎是：每当调用signal handler的时候，Linux都会为应用重新创建一个栈让signal handler跑在上面，在创建这个栈的时候最下面的`ra`会被设置为`sigreturn`使得handler返回之后自动回到`sigreturn`进行回收和恢复上下文工作（顺带一提，这种玩法还能够被用在第八章的线程handler上面）。这意味着在Linux中，这个函数不应该被应用手动调用。另外，信号应该是per-thread的。

* 应避免在多线程进程中使用`sigprocmask`，而应该使用`pthread_sigmask`。Tutorial目前应该采用的是当`how`为`SIG_SETMASK`的语义：就是直接总体上设置当前进程屏蔽的信号集合。那么我们后续是否要修改呢，或者是换成一个其他的名字？参数名最好换成`sigset`，这样更加明确一些

* 那么比较令人疑惑的还剩下一点：per-action的mask是如何设置并生效的？应该是在`sigaction`调用的时候设置并在执行signal handler的时候生效的。

* `ctrl+c`的原理有待观察

  目前`ctrl+c`的逻辑在`Stdin`里面，但其实这个逻辑应该实现在`user_shell`里面，不然的话`infloop`无法`ctrl+c`

  目前在`sig_ctrlc`里面，是不断轮询`getchar`，这样能够触发`stdin`，但是一般情况下应该是怎么搞呢？

  看到一篇`tty`的[深度好文](http://linusakesson.net/programming/tty/index.php)

> **行编辑**
>
> 从终端的角度来说，OS应该提供编辑缓冲区以及退格等功能而非应用（应用应该尽可能简单），这些功能应该由line discipline默认开启
>
> 一些更高级的应用则将line discipline设置为raw模式从而自行处理所有行编辑命令
>
> 内核提供多种不同的line disciplines，但是同一时间只能有一个接入到某个给定的串行设备，默认的被称为`n_tty`
>
> **会话管理**
>
> `tty`driver：使得用户可以同时运行多个程序，但同一时间最多只与一个程序交互（这里开始有了前台和后台进程{组？}之分，只有前台进程能够连接到标准输入输出；当后台进程尝试输出到标准输出的时候，它应当被暂停）；`tty` driver并非“活着的”（alive），意思是说它作为一个数据结构只会被被动调用。如果我没理解错的话，`tty`驱动应该是负责将标准输入输出正确绑定到前台进程上。
>
> 一个`tty`设备是`uart`驱动、line discipline（负责行编辑）和`tty`驱动（负责会话管理）的三元组
>
> **任务控制**
>
> 每一个管道流水线（pipeline）都是一个进程组，可以被统一控制。父进程`fork`出来的子进程在同一个进程组中。shell比较特殊，每启动一个新的管道流水，都会创建一个新的进程组
>
> `tty`驱动被动的维护当前前台进程的进程ID。会话leader（即shell）则会在有必要的时候对它显式更新。
>
> 每个会话（包含多个job）都被一个会话leader（也就是shell，同样是一个job）管理；`tty`驱动（内核数据结构）会维护会话leader进程组和前台进程组；虽然所有的进程都绑定到相同的标准输入输出，但是只有前台进程组能够读写`tty`设备，如果其他进程组尝试这样做将会被内核通过信号暂停
>
> **信号...**
>
> `tty`设备文件也属于UNIX文件，可以被读写，还可以通过`ioctl`配置。然而，`ioctl`需要由应用发起，因此当内核需要与应用异步通信的时候无法使用。信号是允许内核与应用异步通信的一种机制，内核发给应用的通常是致命的信号。
>
> 用作掩码的时候，似乎当前tutorial的实现不太匹配。
>
> `SIGINT`原理：当`^C`出现在输入流的时候，`SIGINT`由`tty`驱动发送给当前的前台进程（组）。这样看来先前`stdin`的实现还是有点道理的。注意`tty`驱动是在内核态的，参考实现如`drivers/char/tty_io.c`。
>
> **一个例子**
>
> 当按下`^Z`之后，line discipline子系统立即发信号`SIGTSTP`给前台进程组...后面很复杂，其实我们只是想知道到底是谁发了信号？
>
> **思考**
>
> 考虑一种最简单的情况：串口（输入输出设备）|串口驱动|`tty`驱动（因为纯用户态貌似搞不定？）|连接到该tty的多进程
>
> 首先，多进程里面有一个会话leader，也就是shell，（同一时间）有一个能实际与I/O打交道的前台进程，剩下的则是后台进程
>
> 这些进程统称为一个会话，连接到一个tty设备
>
> 那么当按下`^C`的时候，比如是在中断处理的时候将字符加入缓冲区（又称输入流），发现这个字符是`^C`之后，应该在加入缓冲区的同时进行处理：找到tty设备绑定到的会话的前台进程然后发一个`SIGINT`的信号给它，这种做法需要在内核里面维护前台进程是哪个。另一种做法可能是直接发一个`SIGINT`的信号给终端，然后在终端的`SIGINT`信号handler中再发`SIGINT`信号给前台进程。
>
> 无论如何，可以看到问题的关键在串口驱动这一端。第九章之前我们将标准I/O读视为一个被动调用的接口，是不能满足这里的需求的。在引入串口中断之后，问题可以得到解决。所以不妨将`^C`放在第九章里面吧（可以作为用户态编程作业？）。鼓励一下自己：似乎对于I/O的理解又有进步。
>
> 根据上面的分析，我们先将`^C`的测例删掉，第九章再加回来。
>
> ```rust
> #![no_std]
> #![no_main]
> 
> extern crate user_lib;
> use user_lib::console::getchar;
> use user_lib::*;
> 
> const LF: u8 = 0x0au8;
> const CR: u8 = 0x0du8;
> 
> fn func() {
>     println!("signal_handler: caught signal SIGINT, and exit(1)");
>     exit(1);
> }
> 
> #[no_mangle]
> pub fn main() -> i32 {
>     println!("sig_ctrlc starting....  Press 'ctrl-c' or 'ENTER'  will quit.");
> 
>     let mut new = SignalAction::default();
>     let old = SignalAction::default();
>     new.handler = func as usize;
> 
>     println!("sig_ctrlc: sigaction");
>     if sigaction(SIGINT, &new, &old) < 0 {
>         panic!("Sigaction failed!");
>     }
>     println!("sig_ctrlc: getchar....");
>     loop {
>         let c = getchar();
> 
>         println!("Got Char  {}", c);
>         if c == LF || c == CR {
>             break;
>         }
>     }
>     println!("sig_ctrlc: Done");
>     0
> }
> 
> ```
>
> 

* `sig_tests`各测例的病情有待观察。

  前情提要：`func`打印字符串并`sigreturn`，`func2`是一个`print("")`的死循环，`func3`打印一行`interrupt`然后`sigreturn`（和`func`有什么区别？）

  `failsignum`:看上去还行

  `kill`:注册`SIGUSR1`的handler为`func`，然后通过`kill`给自己发一个`SIGUSR1`

  `multiprocsignals`:父进程给子进程发一个`SIGUSR1`，子进程则是注册`SIGUSR1`的handler为`func`（备注：这两者的先后关系理应没有影响，但是子进程最好spin，否则可能看不到`func`的输出）

  `restore`:这个单纯为了测试`sigaction`在new和old之间转换的正确性

  `k_ignore`:首先屏蔽`SIGSTOP`，然后再给自己发一个`SIGSTOP`，那么理应没有任何影响

  `k_stop_cont`:父进程sleep 5秒之后给子进程发`SIGCONT`然后等待子进程；子进程给自己发`SIGSTOP`然后sleep 1秒，之后退出。这里首先是sleep的使用有些诡异

  `k_fallignorekill`:这个是测试不允许给`SIGKILL`注册handler([这里](https://linux.die.net/man/2/sigaction)提到了不允许给`SIGKILL`或`SIGSTOP`注册handler)

  `final_sig_test`:父进程先sleep 1秒，然后给子进程通过kill发一个`SIGALRM`，然后再sleep 1秒，然后给子进程发`SIGKILL`；子进程注册`SIGUSR1`的handler为`func2`，注册`SIGALRM`的handler为`func3`，然后给自己发一个`SIGUSR1`(参考[这篇文章](https://linuxhint.com/sigalarm_alarm_c_language/)，`SIGALRM`似乎另有作用，因此将`SIGALRM`换成`SIGUSR2`更好；此外，观察到这个测例有一定概率崩溃，原因不明，可能父进程sleep的时间更长会好一些)

* 第七章的`user_shell`已经支持管道了，但文档没有更新（或者这个可以留作习题？）

### 第八章

* 线程handler不用应用手动调用`exit`
* 兼容信号处理模块：per-process还是per-thread?

## 代码更新

* 类似于`TaskControlBlock`的`Clone` trait
* 文件系统一节非常奇怪的`get_mut`之类的东西（命名不当，其他章节也有出现`get_*`的接口，好像不太Rust）

* 参考一下第九章里面`UPIntrFreeCell`的`exclusive_session`接口，感觉还是挺舒服的

  注：这个不用手动回收，在函数调用边界的时候大概比较好用，但是其他时候就不怎么灵活了
  
* 每次编译完应用之后都会有一大堆输出...

## 文档更新

* 一种比较好用的模式可能是：接口定义->测例分析->内核实现
* 算法合集
  * 第四章：内存管理&页表替换
  * 第五章：各种调度
  * 第六章：也许有不同的文件系统实现？
  * 第八章：并发（这一章总体都需要重铸）

