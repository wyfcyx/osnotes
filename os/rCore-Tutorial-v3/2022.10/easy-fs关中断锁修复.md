问题见[这里](https://github.com/rcore-os/rCore-Tutorial-v3/issues/104)。

初步尝试了一下把easy-fs里面全部换成和tutorial里面一样的关中断锁，结果出现了Multiple borrow的现象。感觉上应该是：

1. 进入文件系统处理（目前观察应该是`sys_exec->open_file->ROOT_INODE.find`，里面是对整个EFS上了一把锁）
2. 这把锁是关中断锁，持有锁的时候会关中断，

那为什么之前是没问题的？之前的话文件系统里面是简单的自旋锁，假设在某次系统调用的时候抢到了这把锁，然后进入内核设施...

可能需要重新思考一下引入关中断锁之后，阻塞机制有了什么变化。

现在的话底层机制应该不能再是这种`RefCell`，而是需要改成自旋锁（单核上可以加一个让权等待优化），为什么？

至少现在的同步设施是有问题的，内核里面的条件变量和锁没有关系，所以也不会释放并获取锁。

---

另外，据说ch8上面的一个问题是要不断的按回车才能有输出...?这个我倒是还没碰到过。

---

同时，ch9即使在内核中关中断也仍然不能解决问题。但是如果块设备换成轮询式访问就能跑。

---

easy-fs中涉及到`read_block`和`write_block`的位置需要小心设计调用`exclusive_access`的位置。这样其实也就是所说的“不要在持有锁的情况下进入阻塞。”其实我们并没有认真考虑引入了阻塞机制之后，之前的同步原语需要有哪些变化。

首先来看一下给内核使用的`CondVar`是什么东西吧。在内核里面`read/write_block`的时候会直接`sched`切换（其实我在想是否某些系统调用执行期间不应该打开中断？至少现在应该没这个问题）。这样的话，一旦在此之前在拿了Cell的情况下进入阻塞，在相应的中断到来唤醒该线程之前，另一个线程尝试拿这个Cell，就会panic了。

一个说法是：“引入阻塞之后，就不能使用Cell而需要换成自旋锁（尽管是带有让权等待优化的）了”。因为在阻塞的时候，被阻塞的线程可能已经持有了一些Cell。之后，如果有其他线程也需要获取Cell，这个时候它应该让权等待或者自旋（这里内核态时钟中断就一定要打开了，不然显然会直接死在内核里。）这里有必要深入分析一下：其实我们可以在内核态时钟中断的时候进行任务切换，目前想来应该没有什么问题，只有这样的话才能用自旋锁，但是单核上其实仍没有意义；让权等待就是发现被占用的时候直接yield，或者阻塞-唤醒。这也许像是个睡眠锁？

所以，看起来我们可以有两种锁：自旋锁和条件变量（其实就是睡眠锁，一会看看xv6研究一下是不是一个东西。）

那么Cell这种方式为什么不行，为什么之前没问题，在什么条件下不行呢？**其实是引入阻塞之后，`exclusive_access`语义就不能保证了！**具体来说，一旦在拿着某个`exclusive_access`的情况下进入阻塞则会导致后续的panic。其实之前用yield也有这样的情况，注意在yield之前是需要把手里拿着的所有`exclusive_access`释放的。然而现在引入阻塞之后可能却没有这样做过。

> 关中断锁和Trap return的交互问题：这个无所谓，反正一开始进入内核态的时候，`sstatus.sie`都是0。
>
> 带着关中断锁阻塞会有什么情形：在系统调用的时候，如果当前关中断锁的层数大于0，是否可以打开中断？至少如果是Cell肯定不行，如果是有让权等待的锁也肯定不行，因为无论怎么样这次中断都卡死了！也就是说，在系统调用中准备打开中断之前需要检查关中断锁层数！让我们看看xv6是否存在类似的处理。

---

学习xv6指导书并发部分。

锁嵌套的原因：多种共享资源之间存在依赖关系。为了防止死锁，其中的关键是各种共享资源也需要是有层次的。

提到有很多长度为2的锁的链是跟sleep有关的：比如在串口中断服务例程中，首先需要获取串口结构的锁，然后有可能需要唤醒等待串口输入的进程，这里显然就需要拿到进程锁。这对应到一条防死锁规则：串口锁必须先于任何进程锁。（这是偏序吗？有传递性吗？）文件子系统中，锁的链条则是比较长的。

**完全避免死锁可能是极其困难的**。比如说模块a调用模块b，但是却要求模块b的锁必须先于模块a的锁被获取；有的时候锁的获取情况甚至是**编译期无法预测、运行期可变**的。这里可能涉及到各种情况。总的来说，**死锁是制约锁的粒度减小、并发性能提高的一个限制条件，因为拆分成更多种类的锁总是会更容易导致死锁**。

> 碎碎念：存在程序分析方法自动生成内核的锁依赖关系图，或者对于一个给定的程序位置输出此时持有的锁的所有可能情况吗？以及，所有锁的生命周期一定构成一颗树吗（也即，任意两把锁要么为outlive关系，要么不相交）？

**关中断锁**：一些自旋锁被线程和中断服务例程同时使用，如果使用不当（中断介入时）容易导致死锁。~~特别是，**在中断时遇到无法获取锁这种情况无法继续向下执行是无法接受的**。首先是在中断里面不能yield或者阻塞；其次是这不太符合中断的定位。但是如果中断里面尝试获取一把其他线程正在拿着的锁是否可以呢？还是不行，因为其他线程能拿意味着当前线程也能拿。~~于是要如何做？指导书里面的说法是：如果中断handler中会用到某把锁L，那么在开启中断的情况下CPU不能获取这把锁。所以就需要识别哪些可能是在中断handler中会被获取的锁（可能需要程序分析），在CPU执行线程的时候，在获取这些锁之前需要先关中断（这里有个顺序问题，是先关中断再尝试获取，还是获取到了之后再关中断？）。本段删除线的说法是错误的，因为关中断只影响当前CPU，我们不可能去把所有CPU的中断都关掉。所以，中断handler可能需要等待其他线程释放锁，但这是能做到的，不会构成死锁。

xv6针对关中断锁采用的是一种较为保守的方案：在`spinlock`前后分别使用`push_off`和`pop_off`来维护当前关中断锁层数。上段问题：获取到之后再关中断显然不行，因为可能获取到之后、关中断之前触发中断然后GG。这里在从0变1层的时候会记录当前锁是否启用。然后回到0层的时候会按照之前记录的情况恢复。这中间都是关中断状态吗？这大概要讨论这样几个问题：在变成1层之前是在执行系统调用还是在中断handler中？中间是否涉及到返回用户态或者进行任务切换？这里指导书并没有强调，我们需要自己考虑一下。

**睡眠锁**：xv6给出其应用场景是当持有一把锁的时间可能很长，导致另一个线程忙等浪费CPU时间很长的情形。指导书中说：“不能在持有锁的情况下交出CPU，不然会导致死锁。”这应该只在xv6这种设计中成立。因为`spinlock`都带有关中断功能，假设一个线程持有锁的情况下交出CPU，另一个线程**在相同CPU上执行**，在`acquire`该锁的时候显然已经是关中断的，这就死锁了。所以说就需要一种锁满足：在尝试获取该锁的时候可以yield，**在持有该锁之后也可以yield或者允许中断进入**。数据结构如下：

```c
// Long-term locks for processes
struct sleeplock {
  uint locked;       // Is the lock held?
  struct spinlock lk; // spinlock protecting this sleep lock
  
  // For debugging:
  char *name;        // Name of lock.
  int pid;           // Process holding lock
};

// 尝试获取一把sleeplock，在等待的时候可以让出CPU，这其实就是一个条件变量wait操作
void
acquiresleep(struct sleeplock *lk)
{
  acquire(&lk->lk);
  // 这里是关中断的
  while (lk->locked) {
    sleep(lk, &lk->lk);
  }
  lk->locked = 1;
  lk->pid = myproc()->pid;
  release(&lk->lk);
}
// 释放一把sleeplock，也是典型的条件变量signal
void
releasesleep(struct sleeplock *lk)
{
  acquire(&lk->lk);
  lk->locked = 0;
  lk->pid = 0;
  wakeup(lk);
  release(&lk->lk);
}

// 这个好像只是检查一下当前进程有没有拿着某个sleeplock
int
holdingsleep(struct sleeplock *lk)
{
  int r;
  
  acquire(&lk->lk);
  r = lk->locked && (lk->pid == myproc()->pid);
  release(&lk->lk);
  return r;
}
```

